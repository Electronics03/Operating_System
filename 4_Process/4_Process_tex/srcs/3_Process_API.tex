\section{Process API}
The operating system provides system calls to create, execute, and terminate processes.
\texttt{fork()}, \texttt{wait()}, and \texttt{exec()} are the core process-control primitives.
\begin{itemize}
    \item \texttt{fork()}: creates a new process so that parent and child can run concurrently (with copy-on-write address space).
    \item \texttt{wait()}: blocks the parent until the child finishes, allowing the parent to reap the child's exit status (avoiding zombies).
    \item \texttt{exec()}: replaces the current process's memory image with a new program (PID is preserved).
\end{itemize}
By combining these three APIs, the OS can launch a new program
when a user issues a command, while ensuring the parent process is synchronized
with the completion of the child.

\subsection{\texttt{fork()}}
\texttt{fork()} creates a child process. The child has its own register state and program counter, and initially shares the
address space via copy-on-write. At the point of the \texttt{fork()} call, both parent and child return from \texttt{fork()}
to their respective control flows. Return values:
\begin{itemize}
    \item In the parent: returns the child's PID
    \item In the child: returns 0
    \item On error: returns -1
\end{itemize}

Example code from \cite{ArpaciDusseau23-Book}:
\begin{center}
    \begin{minipage}{0.9\linewidth}
        \begin{minted}{c}
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(int argc, char *argv[])
{
    printf("hello world (pid:%d)\n", (int)getpid());
    int rc = fork();
    if (rc < 0)
    {
        fprintf(stderr, "fork failed\n");
        exit(1);
    }
    else if (rc == 0)
    {
        printf("hello, I am child (pid:%d)\n", (int)getpid());
    }
    else
    {
        printf("hello, I am parent of %d (pid:%d)\n",
               rc, (int)getpid());
    }
    return 0;
}
\end{minted}
    \end{minipage}
\end{center}

\subsection{\texttt{wait()}}
\texttt{wait()} blocks the parent until the child terminates and reaps its exit status, preventing zombie processes.
This ensures the child terminates first, allowing the parent to collect its exit status.

Example code from \cite{ArpaciDusseau23-Book}:
\begin{center}
    \begin{minipage}{0.9\linewidth}
        \begin{minted}{c}
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

int main(int argc, char *argv[])
{
    printf("hello world (pid:%d)\n", (int)getpid());
    int rc = fork();
    if (rc < 0)
    {
        fprintf(stderr, "fork failed\n");
        exit(1);
    }
    else if (rc == 0)
    {
        printf("hello, I am child (pid:%d)\n", (int)getpid());
    }
    else
    {
        int wc = wait(NULL);
        printf("hello, I am parent of %d (wc:%d) (pid:%d)\n",
               rc, wc, (int)getpid());
    }
    return 0;
}
\end{minted}
    \end{minipage}
\end{center}

\subsection{\texttt{exec()}}
Unlike \texttt{fork()}, \texttt{exec()} does not create a new process; it replaces the current process's memory image with a new
program. The PID stays the same, but code, data, heap, and stack are replaced.
\texttt{exec()} takes two parameters: (i) the pathname of the program to execute and (ii) an \texttt{argv} array of arguments.
By convention, \texttt{argv[0]} is the program name and the array is \texttt{NULL}-terminated.

\texttt{exec()} takes two arguments:
\begin{itemize}
    \item the name of the file to execute
    \item \texttt{argv[]}: the argument array passed to the program
\end{itemize}

Example code from \cite{ArpaciDusseau23-Book}:
\begin{center}
    \begin{minipage}{0.9\linewidth}
        \begin{minted}{c}
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/wait.h>

int main(int argc, char *argv[])
{
    printf("hello world (pid:%d)\n", (int)getpid());
    int rc = fork();
    if (rc < 0)
    {
        fprintf(stderr, "fork failed\n");
        exit(1);
    }
    else if (rc == 0)
    {
        printf("hello, I am child (pid:%d)\n", (int)getpid());
        char *myargs[3];
        myargs[0] = strdup("wc");
        myargs[1] = strdup("p3.c");
        myargs[2] = NULL;
        execvp(myargs[0], myargs);
        printf("this shouldnâ€™t print out");
    }
    else
    {
        int wc = wait(NULL);
        printf("hello, I am parent of %d (wc:%d) (pid:%d)\n",
               rc, wc, (int)getpid());
    }
    return 0;
}
\end{minted}
    \end{minipage}
\end{center}

When \texttt{execvp()} is called, the child replaces its memory space
with the program \texttt{wc p3.c}.
If successful, the subsequent line
\texttt{printf("this shouldn't print out")} is never executed.
Meanwhile, the parent waits for the child to finish and then prints both PIDs.